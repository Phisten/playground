package leetcode

import (
	"reflect"
	"testing"
)

func Test_c2972(t *testing.T) {
	type Pair struct {
		got      int
		expected int
		note     string
	}

	Func := incremovableSubarrayCount
	paris := []Pair{
		{Func([]int{1, 2, 3, 4}), 10, ""},
		{Func([]int{6, 5, 7, 8}), 7, ""},
		{Func([]int{8, 7, 6, 6}), 3, ""},
	}

	for i, v := range paris {
		if !reflect.DeepEqual(v.expected, v.got) {
			f := "i:%v Expected %v, but got %v, note:%v"
			t.Errorf(f, i, v.expected, v.got, v.note)
		}
	}
}

// highlight 影響遞增的部分
// 若沒有就是最大組合
func incremovableSubarrayCount(nums []int) int {
	l := len(nums)

	if l <= 1 {
		return 1
	}

}

/*
重來




------------
1232


6578
 ^

[0]<[2]
 (5)
 (57)
 (578)
(65)
(657)
(6578)

(6)







---
dp疊算
1 2 = (1)(2)(12) = 3
1 = (1) = 1
1 2 3 = (1)(2)(12) (3)(23)(123) = 6
1 2 3 4 =  (1)(2)(12) (3)(23)(123) (4)(34)(234)(1234) = 10
12345= 10+(5)(54)(543)(5432)(54321)=15=len(nums)! = 5!


不增idx在5
65=(6)(5)(65)=3
657=3+(57)(657)=5
6578=5+(578)(6578)=7



不增點有第二個時要重置前面累計數=1(全部清除)
87=(8)(7)=2
876=(87)[reset] (76)(876)



122212224
1=(1)1
12=(1)(2)(12)=3
122=3[12]-1[1] +(2)(22)(122)=5
1222=5[122]-3[12]+(22)(222)(1222)=5
12222=5[1222]-5[122]+(222)()

感覺沒有規律
----
左右反向分治
先找到不增點有幾個
沒有就直接輸出n!
從左往右找不增的
從右往左找減的

note: 在中間特別長怎麼辦？
56123456712

(56)(12)(5)(2)()
由於無法保留最中間那段（只能去一邊）
所以沒用  視為一個單位
 5671234
l   ^
r  ^
l(5)(56)(567)
r(4)(34)(234)(1234)
() 全清
=len(l)+len(r)+1
最後算刪中間的情況怎麼刪
能否拼起

 122222
l  ^
r    ^
l(1)(12)
r(2)
()
ans=4





[1,2,3,4]
[6,5,7,8]
[8,7,6,6]


*/
